<!DOCTYPE html SYSTEM "about:legacy-compat">
<html lang="en-US" data-preset="contrast" data-primary-color="#307FFF"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="robots" content="noindex"><meta name="built-on" content="2024-04-03T22:11:55.285559254"><title>Principes OO | Help Instance</title><script type="application/json" id="virtual-toc-data">[{"id":"clean-code-a-handbook-of-agile-software-craftsmanship","level":0,"title":"Clean Code : A Handbook of Agile Software Craftsmanship","anchor":"#clean-code-a-handbook-of-agile-software-craftsmanship"},{"id":"solid","level":0,"title":"SOLID","anchor":"#solid"},{"id":"autres-principes","level":0,"title":"Autres Principes","anchor":"#autres-principes"}]</script><script type="application/json" id="topic-shortcuts"></script><link href="https://resources.jetbrains.com/writerside/apidoc/6.6.6-b224/app.css" rel="stylesheet"><link rel="manifest" href="site.webmanifest"><meta name="msapplication-TileColor" content="#000000"><link rel="apple-touch-icon" sizes="180x180" href="https://jetbrains.com/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="https://jetbrains.com/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="https://jetbrains.com/favicon-16x16.png"><meta name="msapplication-TileImage" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-144x144.png"><meta name="msapplication-square70x70logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-70x70.png"><meta name="msapplication-square150x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-150x150.png"><meta name="msapplication-wide310x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x150.png"><meta name="msapplication-square310x310logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x310.png"><meta name="image" content=""><!-- Open Graph --><meta property="og:title" content="Principes OO | Help Instance"><meta property="og:description" content=""><meta property="og:image" content=""><meta property="og:site_name" content="Help Instance Help"><meta property="og:type" content="website"><meta property="og:locale" content="en_US"><meta property="og:url" content="writerside-documentation/principesoo.html"><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content=""><meta name="twitter:title" content="Principes OO | Help Instance"><meta name="twitter:description" content=""><meta name="twitter:creator" content=""><meta name="twitter:image:src" content=""><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json">{
    "@context": "http://schema.org",
    "@type": "WebPage",
    "@id": "writerside-documentation/principesoo.html#webpage",
    "url": "writerside-documentation/principesoo.html",
    "name": "Principes OO | Help Instance",
    "description": "",
    "image": "",
    "inLanguage":"en-US"
}</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json">{
    "@type": "WebSite",
    "@id": "writerside-documentation/#website",
    "url": "writerside-documentation/",
    "name": "Help Instance Help"
}</script><!-- End Schema.org --></head><body data-id="principesOO" data-main-title="Principes OO" data-article-props="{&quot;seeAlsoStyle&quot;:&quot;links&quot;}" data-template="article" data-breadcrumbs="Patrons-de-conception.md|Patrons de conception"><div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>Help Instance  Help</h3><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="principesOO" id="principesOO.md">Principes OO</h1><section class="chapter"><h2 id="clean-code-a-handbook-of-agile-software-craftsmanship" data-toc="clean-code-a-handbook-of-agile-software-craftsmanship">Clean Code : A Handbook of Agile Software Craftsmanship</h2><p id="iqq0r8_1473">Ce livre influent, &eacute;crit par Robert C. Martin, qui est &eacute;galement connu sous le nom de &quot;Uncle Bob&quot;. L'objectif de ce livre est d'enseigner aux d&eacute;veloppeurs de logiciels les principes de l'&eacute;criture de logiciels de haute qualit&eacute;. Voici un bref r&eacute;sum&eacute; de certains des concepts cl&eacute;s pr&eacute;sent&eacute;s dans le livre :</p><ol class="list _decimal" id="iqq0r8_1474" type="1"><li class="list__item" id="iqq0r8_1475"><p id="iqq0r8_1476"><span class="control" id="iqq0r8_1477">Code propre</span>: L'auteur d&eacute;finit le &quot;code propre&quot; comme un code qui a &eacute;t&eacute; &eacute;crit par quelqu'un qui se soucie r&eacute;ellement de son travail. Pour lui, un bon code peut &ecirc;tre lu et am&eacute;lior&eacute; par d'autres d&eacute;veloppeurs, et a une structure claire.</p></li><li class="list__item" id="iqq0r8_1478"><p id="iqq0r8_1479"><span class="control" id="iqq0r8_1480">Noms significatifs</span>: Les noms pour les fonctions, les variables et les classes doivent &ecirc;tre clairs et pr&eacute;cis. Ils devraient r&eacute;v&eacute;ler leur intention et ne laisser aucune place &agrave; l'ambigu&iuml;t&eacute;.</p></li><li class="list__item" id="iqq0r8_1481"><p id="iqq0r8_1482"><span class="control" id="iqq0r8_1483">Fonctions</span>: Les fonctions doivent &ecirc;tre petites et ne faire qu'une seule chose. Elles devraient seulement avoir un niveau d'abstraction et les commentaires doivent &ecirc;tre &eacute;vit&eacute;s autant que possible. L'auteur explique en d&eacute;tail comment cr&eacute;er des fonctions efficaces.</p></li><li class="list__item" id="iqq0r8_1484"><p id="iqq0r8_1485"><span class="control" id="iqq0r8_1486">Commentaires</span>: En r&egrave;gle g&eacute;n&eacute;rale, les commentaires devraient &ecirc;tre &eacute;vit&eacute;s. Un bon code est auto-document&eacute;. Si vous devez &eacute;crire des commentaires pour expliquer votre code, il serait pr&eacute;f&eacute;rable de le r&eacute;&eacute;crire.</p></li><li class="list__item" id="iqq0r8_1487"><p id="iqq0r8_1488"><span class="control" id="iqq0r8_1489">Formattage</span>: Il est essentiel d'avoir un bon format pour votre code. Un bon format facilite la lisibilit&eacute; et la compr&eacute;hension du code.</p></li><li class="list__item" id="iqq0r8_1490"><p id="iqq0r8_1491"><span class="control" id="iqq0r8_1492">Gestion des erreurs</span>: L'auteur sugg&egrave;re que les erreurs doivent &ecirc;tre g&eacute;r&eacute;es correctement en utilisant des exceptions plut&ocirc;t que des codes d'erreur retourn&eacute;s.</p></li><li class="list__item" id="iqq0r8_1493"><p id="iqq0r8_1494"><span class="control" id="iqq0r8_1495">R&eacute;p&eacute;tition de code</span>: La r&eacute;p&eacute;tition de code est une mauvaise habitude qui peut rendre votre code ennuyeux et difficile &agrave; maintenir. Utiliser des abstractions et des m&eacute;thodes pour &eacute;viter la duplication du code.</p></li><li class="list__item" id="iqq0r8_1496"><p id="iqq0r8_1497"><span class="control" id="iqq0r8_1498">Principes SOLID</span>: Il explique &eacute;galement certains principes de la conception orient&eacute;e objet, tels que les principes SOLID : <span class="emphasis" id="iqq0r8_1499">Single Responsibility</span>, <span class="emphasis" id="iqq0r8_1500">Open/Closed</span>, <span class="emphasis" id="iqq0r8_1501">Liskov Substitution</span>, <span class="emphasis" id="iqq0r8_1502">Interface Segregation</span> et <span class="emphasis" id="iqq0r8_1503">Dependency Inversion</span>.</p></li><li class="list__item" id="iqq0r8_1504"><p id="iqq0r8_1505"><span class="control" id="iqq0r8_1506">Code smells et refactorisation</span>: Le livre pr&eacute;sente &eacute;galement diff&eacute;rentes &quot;odeurs de code&quot; (<span class="emphasis" id="iqq0r8_1507">code smells</span>) qui indiquent d'&eacute;ventuels probl&egrave;mes de conception du code et montre comment ces probl&egrave;mes peuvent &ecirc;tre r&eacute;solus par le refactorisation.</p></li></ol><p id="iqq0r8_1508">En r&eacute;sum&eacute;, &quot;Clean Code&quot; est une ressource pr&eacute;cieuse pour tout d&eacute;veloppeur de logiciels cherchant &agrave; am&eacute;liorer ses comp&eacute;tences en codage et &agrave; &eacute;crire des logiciels de meilleure qualit&eacute;.</p></section><section class="chapter"><h2 id="solid" data-toc="solid">SOLID</h2><p id="iqq0r8_1509"><a href="https://en.wikipedia.org/wiki/SOLID" id="iqq0r8_1510" data-external="true" rel="noopener noreferrer">https://en.wikipedia.org/wiki/SOLID</a></p><p id="iqq0r8_1511"><a href="https://fr.wikipedia.org/wiki/SOLID_(informatique)" id="iqq0r8_1512" data-external="true" rel="noopener noreferrer">https://fr.wikipedia.org/wiki/SOLID_(informatique)</a></p><p id="iqq0r8_1513"><span class="control" id="iqq0r8_1514">SOLID</span> est un acronyme pour un ensemble de cinq principes de conception de logiciels orient&eacute;s objet qui aident &agrave; rendre les syst&egrave;mes de logiciels plus compr&eacute;hensibles, flexibles et maintenables. Voici ce que chaque lettre de l'acronyme SOLID signifie :</p><ol class="list _decimal" id="iqq0r8_1515" type="1"><li class="list__item" id="iqq0r8_1516"><p id="iqq0r8_1517"><span class="control" id="iqq0r8_1518">S - Principe de Responsabilit&eacute; Unique (Single Responsibility Principle)</span>: Ce principe stipule qu'une classe ou un module devrait avoir une, et seulement une, raison de changer. En d'autres termes, une classe ou un module devrait avoir une seule responsabilit&eacute; ou t&acirc;che.</p></li><li class="list__item" id="iqq0r8_1519"><p id="iqq0r8_1520"><span class="control" id="iqq0r8_1521">O - Principe ouvert/ferm&eacute; (Open/Closed Principle)</span>: Ce principe stipule que les entit&eacute;s logicielles (classes, modules, fonctions, etc.) devraient &ecirc;tre ouvertes &agrave; l'extension, mais ferm&eacute;es &agrave; la modification. Cela signifie que vous devriez &ecirc;tre capable d'ajouter de nouvelles fonctionnalit&eacute;s &agrave; une entit&eacute; sans modifier son code source.</p></li><li class="list__item" id="iqq0r8_1522"><p id="iqq0r8_1523"><span class="control" id="iqq0r8_1524">L - Principe de substitution de Liskov (Liskov Substitution Principle)</span>: Ce principe stipule que dans un programme, les objets d'une superclasse devraient pouvoir &ecirc;tre remplac&eacute;s par des objets d'une sous-classe sans affecter l'exactitude de ce programme.</p></li><li class="list__item" id="iqq0r8_1525"><p id="iqq0r8_1526"><span class="control" id="iqq0r8_1527">I - Principe de s&eacute;gregation d'interface (Interface Segregation Principle)</span>: Ce principe stipule que les clients ne devraient pas &ecirc;tre forc&eacute;s de d&eacute;pendre des interfaces qu'ils n'utilisent pas.</p></li><li class="list__item" id="iqq0r8_1528"><p id="iqq0r8_1529"><span class="control" id="iqq0r8_1530">D - Principe d'inversion de d&eacute;pendance (Dependency Inversion Principle)</span>: Ce principe stipule que les modules de haut niveau ne devraient pas d&eacute;pendre des modules de bas niveau. Les deux devraient d&eacute;pendre des abstractions.</p></li></ol><p id="iqq0r8_1531">Suivre ces principes peut aider &agrave; &eacute;viter les mauvaises pratiques de conception, &agrave; r&eacute;duire le couplage dans le code, &agrave; rendre le code plus facile &agrave; maintenir et &agrave; am&eacute;liorer la lisibilit&eacute; et la reproductibilit&eacute; du code.</p><section class="chapter"><h3 id="responsabilit-unique-single-responsibility-principle-srp" data-toc="responsabilit-unique-single-responsibility-principle-srp">Responsabilit&eacute; unique (Single responsibility principle SRP)</h3><p id="iqq0r8_1532"><span class="emphasis" id="iqq0r8_1533">Une classe, une fonction ou une m&eacute;thode doit avoir une et une seule responsabilit&eacute;.</span></p><p id="iqq0r8_1534">Selon le principe de responsabilit&eacute; unique, une classe, un module ou une fonction ne devrait avoir qu'une seule raison de changer. Autrement dit, chaque entit&eacute; logicielle doit &ecirc;tre responsable d'un seul aspect particulier de la fonctionnalit&eacute; du logiciel.</p><p id="iqq0r8_1535">Pour donner un exemple, supposons que vous ayez un objet dans votre application qui g&egrave;re la logique de manipulation des utilisateurs (c'est-&agrave;-dire, l'ajout, la suppression et la mise &agrave; jour des utilisateurs). Si ce m&ecirc;me objet est aussi responsable de l'affichage des utilisateurs &agrave; l'&eacute;cran, alors il a deux raisons de changer : une raison technique ( modification du code pour manipuler les utilisateurs diff&eacute;remment) et une raison esth&eacute;tique (modification du code pour changer l'affichage des utilisateurs &agrave; l'&eacute;cran). C'est une violation du principe SRP.</p><p id="iqq0r8_1536">Ce principe encourage &agrave; s&eacute;parer les pr&eacute;occupations pour am&eacute;liorer la lisibilit&eacute; et la maintenabilit&eacute;</p></section><section class="chapter"><h3 id="ouvert-ferm-open-closed-principle" data-toc="ouvert-ferm-open-closed-principle">Ouvert/ferm&eacute; (Open/closed principle)</h3><p id="iqq0r8_1537"><span class="emphasis" id="iqq0r8_1538">Une entit&eacute; applicative (classe, fonction, module ...) doit &ecirc;tre ferm&eacute;e &agrave; la modification directe, mais ouverte &agrave; l'extension.</span></p><p id="iqq0r8_1539">Le principe Ouvert/ferm&eacute;, souvent abr&eacute;g&eacute; en OCP (Open/Closed Principle), est un concept important en programmation orient&eacute;e objet, et est l'un des cinq principes fondamentaux du SOLID, un acronyme pour un ensemble de principes de conception orient&eacute;e objet con&ccedil;us pour rendre le code plus compr&eacute;hensible, flexible et maintenable.</p><p id="iqq0r8_1540">Selon le principe Ouvert/ferm&eacute;, souvent abr&eacute;g&eacute; en OCP (Open/Closed Principle), les entit&eacute;s logicielles (classes, modules, fonctions, etc.) doivent &ecirc;tre ouvertes &agrave; l'extension, mais ferm&eacute;es &agrave; la modification. Cela signifie que vous devriez pouvoir ajouter de nouvelles fonctionnalit&eacute;s ou comportements &agrave; une entit&eacute; sans avoir &agrave; modifier son code source.</p><p id="iqq0r8_1541">L'intention est de r&eacute;duire le risque de nouvelles erreurs et r&eacute;duire les d&eacute;pendances dans le syst&egrave;me. De cette fa&ccedil;on, lorsque nous ajoutons de nouvelles fonctionnalit&eacute;s ou changeons le comportement du syst&egrave;me, nous ajoutons du nouveau code (extension), nous n'avons pas besoin de modifier le code existant (ferm&eacute; pour modification).</p><p id="iqq0r8_1542">Un exemple de la mani&egrave;re d'appliquer l'OCP est l'utilisation de <span class="control" id="iqq0r8_1543">polymorphisme</span> o&ugrave; la classe de base reste la m&ecirc;me et de nouvelles fonctionnalit&eacute;s sont ajout&eacute;es en cr&eacute;ant de nouvelles classes qui h&eacute;ritent de la classe de base.</p></section><section class="chapter"><h3 id="substitution-de-liskov-liskov-substitution-principle" data-toc="substitution-de-liskov-liskov-substitution-principle">Substitution de Liskov (Liskov substitution principle)</h3><p id="iqq0r8_1544"><span class="emphasis" id="iqq0r8_1545">Une instance de type <code class="code" id="iqq0r8_1546">T</code> doit pouvoir &ecirc;tre remplac&eacute;e par une instance de type <code class="code" id="iqq0r8_1547">G</code>, tel que <code class="code" id="iqq0r8_1548">G</code> sous-type de <code class="code" id="iqq0r8_1549">T</code>, sans que cela modifie la coh&eacute;rence du programme</span>.</p><p id="iqq0r8_1550">Ce principe a &eacute;t&eacute; introduit par Barbara Liskov en 1987 lors d'une conf&eacute;rence. Le principe stipule que si une classe <code class="code" id="iqq0r8_1551">B</code> h&eacute;rite d'une classe <code class="code" id="iqq0r8_1552">A</code>, alors nous devrions &ecirc;tre capables de remplacer <code class="code" id="iqq0r8_1553">A</code> par <code class="code" id="iqq0r8_1554">B</code> sans affecter le comportement de notre programme. C'est-&agrave;-dire, un objet de type superclasse peut &ecirc;tre remplac&eacute; par un objet de type sous-classe sans perturber l'exactitude ou le comportement du programme.</p><p id="iqq0r8_1555">Par exemple, consid&eacute;rons une classe <code class="code" id="iqq0r8_1556">Oiseau</code> qui a une m&eacute;thode <code class="code" id="iqq0r8_1557">voler</code>. Maintenant, consid&eacute;rons une sous-classe <code class="code" id="iqq0r8_1558">Pingouin</code>, qui est un type d'oiseau, mais qui ne peut pas voler. Selon le principe de substitution de Liskov, nous devrions pouvoir utiliser un objet <code class="code" id="iqq0r8_1559">Pingouin</code> l&agrave; o&ugrave; nous utilisons un objet <code class="code" id="iqq0r8_1560">Oiseau</code> dans notre programme. Cependant, si notre programme attend que les oiseaux puissent voler, alors cette substitution causerait un probl&egrave;me, car les pingouins ne peuvent pas voler. C'est une violation du principe de substitution de Liskov.</p><p id="iqq0r8_1561">En substance, le principe de substitution de Liskov encourage &agrave; assurer que les sous-classes soient absolument substituables par leurs superclasses sans alt&eacute;rer la logique du programme. Solliciter ce principe lors de la conception de logiciels aide &agrave; garantir la polymorphie et augmente la r&eacute;utilisabilit&eacute; des modules logiciels.</p></section><section class="chapter"><h3 id="s-gr-gation-des-interfaces-interface-segregation-principle" data-toc="s-gr-gation-des-interfaces-interface-segregation-principle">S&eacute;gr&eacute;gation des interfaces (Interface segregation principle)</h3><p id="iqq0r8_1562"><span class="emphasis" id="iqq0r8_1563">Pr&eacute;f&eacute;rer plusieurs interfaces sp&eacute;cifiques pour chaque client plut&ocirc;t qu'une seule interface g&eacute;n&eacute;rale</span>.</p><p id="iqq0r8_1564">L'ISP stipule que &quot; <span class="emphasis" id="iqq0r8_1565">les clients ne devraient pas &ecirc;tre forc&eacute;s de d&eacute;pendre des interfaces qu'ils n'utilisent pas</span> &quot;. En termes simples, cela signifie que les grandes interfaces monolithiques doivent &ecirc;tre &eacute;vit&eacute;es en faveur de plus petites, plus sp&eacute;cifiques qui sont plus facilement g&eacute;rables et utilisables par les classes.</p><p id="iqq0r8_1566">Pour donner un exemple, supposons que vous ayez une interface <code class="code" id="iqq0r8_1567">Imprimante</code> avec les m&eacute;thodes <code class="code" id="iqq0r8_1568">imprimer</code>, <code class="code" id="iqq0r8_1569">scanner</code> et <code class="code" id="iqq0r8_1570">faxer</code>. C'est bien pour une imprimante multifonction qui peut faire tout cela, mais qu'en est-il d'une imprimante de base qui ne peut qu'imprimer ? Selon l'ISP, il serait pr&eacute;f&eacute;rable d'avoir des interfaces s&eacute;par&eacute;es pour chaque fonctionnalit&eacute;, de sorte que l'imprimante de base n'ait pas besoin de d&eacute;pendre (ou d'impl&eacute;menter de mani&egrave;re artificielle) des m&eacute;thodes <code class="code" id="iqq0r8_1571">scanner</code> et <code class="code" id="iqq0r8_1572">faxer</code> qu'elle ne peut pas utiliser.</p><p id="iqq0r8_1573">L'avantage de l'ISP est qu'il r&eacute;duit le couplage entre les composants et am&eacute;liore leur modularit&eacute;, facilitant ainsi la maintenance, la r&eacute;utilisation et l'&eacute;volution du code.</p></section><section class="chapter"><h3 id="inversion-des-d-pendances-dependency-inversion-principle" data-toc="inversion-des-d-pendances-dependency-inversion-principle">Inversion des d&eacute;pendances (Dependency inversion principle)</h3><p id="iqq0r8_1574"><span class="emphasis" id="iqq0r8_1575">Il faut d&eacute;pendre des abstractions, pas des impl&eacute;mentations</span></p><p id="iqq0r8_1576">Le DIP stipule que :</p><ol class="list _decimal" id="iqq0r8_1577" type="1"><li class="list__item" id="iqq0r8_1578"><p id="iqq0r8_1579">Les modules de haut niveau ne doivent pas d&eacute;pendre des modules de bas niveau. Les deux doivent d&eacute;pendre des abstractions.</p></li><li class="list__item" id="iqq0r8_1580"><p id="iqq0r8_1581">Les abstractions ne doivent pas d&eacute;pendre des d&eacute;tails. Les d&eacute;tails doivent d&eacute;pendre des abstractions.</p></li></ol><p id="iqq0r8_1582">Par &quot;module de haut niveau&quot;, on entend une classe (ou un ensemble de classes) qui est &agrave; un niveau d'abstraction &eacute;lev&eacute;, c'est-&agrave;-dire plus orient&eacute;e vers les objectifs m&eacute;tier. Et par &quot;module de bas niveau&quot;, on entend une classe (ou un ensemble de classes) qui est &agrave; un niveau d'abstraction bas, c'est-&agrave;-dire plus orient&eacute;e vers les d&eacute;tails techniques ou l'infrastructure.</p><p id="iqq0r8_1583">En d'autres termes, plut&ocirc;t que de laisser les classes de haut niveau (plus proches des op&eacute;rations m&eacute;tier) d&eacute;pendre directement des classes de bas niveau (plus proches des op&eacute;rations techniques), les deux devraient d&eacute;pendre d'interfaces abstraites. Ainsi, si les d&eacute;tails de la mise en &oelig;uvre d'une classe de bas niveau doivent changer, cela n'a aucun impact sur les classes de haut niveau.</p><p id="iqq0r8_1584">L'avantage de ce principe est qu'il contribue &agrave; d&eacute;finir un syst&egrave;me fortement coh&eacute;rent mais faiblement coupl&eacute;, ce qui rend le code plus flexible, plus facile &agrave; tester, &agrave; maintenir et &agrave; faire &eacute;voluer.</p></section></section><section class="chapter"><h2 id="autres-principes" data-toc="autres-principes">Autres Principes</h2><section class="chapter"><h3 id="dry-wet" data-toc="dry-wet">DRY / WET</h3><section class="chapter"><h4 id="dry-don-t-repeat-yourself" data-toc="dry-don-t-repeat-yourself">DRY (Don't Repeat Yourself)</h4></section><section class="chapter"><h4 id="oppos-de-dry-wet-write-everything-twice" data-toc="oppos-de-dry-wet-write-everything-twice">Oppos&eacute; de DRY: WET (Write Everything Twice)</h4><p id="iqq0r8_1585"><a href="https://en.wikipedia.org/wiki/Don%27t_repeat_yourself" id="iqq0r8_1586" data-external="true" rel="noopener noreferrer">https://en.wikipedia.org/wiki/Don%27t_repeat_yourself</a></p><p id="iqq0r8_1587"><a href="https://fr.wikipedia.org/wiki/Ne_vous_répétez_pas" id="iqq0r8_1588" data-external="true" rel="noopener noreferrer">https://fr.wikipedia.org/wiki/Ne_vous_r&eacute;p&eacute;tez_pas</a></p><p id="iqq0r8_1589"><span class="control" id="iqq0r8_1590">DRY</span> signifie <span class="control" id="iqq0r8_1591">Don't Repeat Yourself</span> (<span class="emphasis" id="iqq0r8_1592">Ne vous r&eacute;p&eacute;tez pas</span> en fran&ccedil;ais). C'est un principe de d&eacute;veloppement logiciel qui vise &agrave; r&eacute;duire la r&eacute;p&eacute;tition de code. L'id&eacute;e est que chaque morceau de logique doit avoir un emplacement unique et d&eacute;finitif dans le syst&egrave;me. Si vous d&eacute;couvrez que vous &eacute;crivez le m&ecirc;me code &agrave; plusieurs reprises, vous devriez chercher un moyen de le centraliser et de le r&eacute;utiliser, plut&ocirc;t que de le dupliquer. Le respect de ce principe rend le code plus lisible, plus efficace et plus facile &agrave; maintenir.</p><p id="iqq0r8_1593">&Agrave; l'oppos&eacute;, <span class="control" id="iqq0r8_1594">WET</span> signifie <span class="control" id="iqq0r8_1595">Write Everything Twice</span> (<span class="emphasis" id="iqq0r8_1596">&Eacute;crire tout deux fois</span> en fran&ccedil;ais) ou <span class="control" id="iqq0r8_1597">We Enjoy Typing</span> (<span class="emphasis" id="iqq0r8_1598">Nous aimons taper</span> en fran&ccedil;ais). C'est souvent utilis&eacute; de mani&egrave;re humoristique pour d&eacute;crire du code qui viole le principe DRY, c'est-&agrave;-dire du code qui a beaucoup de r&eacute;p&eacute;titions inutiles.</p><p id="iqq0r8_1599">Il est important de noter que le principe DRY n'encourage pas &agrave; &eacute;viter toute duplication &agrave; tout prix. Parfois, essayer d'&eacute;liminer toute duplication peut conduire &agrave; une conception trop complexe et difficile &agrave; comprendre. Il s'agit plut&ocirc;t d'&eacute;viter la duplication de la logique du syst&egrave;me. Une duplication apparemment similaire peut &ecirc;tre acceptable si les motivations et les usages derri&egrave;re elles sont diff&eacute;rents.</p></section></section><section class="chapter"><h3 id="kiss" data-toc="kiss">KISS</h3><p id="iqq0r8_1600"><a href="https://en.wikipedia.org/wiki/KISS_principle" id="iqq0r8_1601" data-external="true" rel="noopener noreferrer">https://en.wikipedia.org/wiki/KISS_principle</a></p><p id="iqq0r8_1602"><a href="https://fr.wikipedia.org/wiki/Principe_KISS" id="iqq0r8_1603" data-external="true" rel="noopener noreferrer">https://fr.wikipedia.org/wiki/Principe_KISS</a></p><section class="chapter"><h4 id="keep-it-simple-stupid" data-toc="keep-it-simple-stupid">Keep it simple, stupid</h4><p id="iqq0r8_1604">En d&eacute;veloppement logiciel, <span class="control" id="iqq0r8_1605">KISS</span> est un acronyme pour <span class="control" id="iqq0r8_1606">Keep It Simple, Stupid</span> (<span class="emphasis" id="iqq0r8_1607">Garde &ccedil;a simple, idiot</span> en fran&ccedil;ais). Ce principe de conception encourage la simplicit&eacute; dans la conception et l'&eacute;criture du code.</p><p id="iqq0r8_1608">L'id&eacute;e est d'&eacute;viter la complexit&eacute; inutile. Par complexit&eacute; inutile, on entend g&eacute;n&eacute;ralement des solutions <span class="emphasis" id="iqq0r8_1609">sur-con&ccedil;ues</span> (<span class="emphasis" id="iqq0r8_1610">over-engineered</span>, ou trop &eacute;labor&eacute;es), c'est-&agrave;-dire qui utilisent des conceptions plus complexes qu'il n'est r&eacute;ellement n&eacute;cessaire pour r&eacute;soudre le probl&egrave;me &agrave; port&eacute;e de main. Une solution plus complexe peut &ecirc;tre plus difficile &agrave; comprendre, &agrave; tester et &agrave; maintenir, et est &eacute;galement plus susceptible d'introduire des bugs.</p><p id="iqq0r8_1611">Dans la pratique, suivre le principe KISS pourrait signifier de privil&eacute;gier une conception plus simple m&ecirc;me si elle est un peu moins &eacute;l&eacute;gante, choisir une solution brute, mais efficace plut&ocirc;t qu'une solution sophistiqu&eacute;e, mais d&eacute;licate, ou pr&eacute;f&eacute;rer des structures de code faciles &agrave; comprendre et &agrave; parcourir &agrave; des structures de code plus &quot;intelligentes&quot; mais potentiellement d&eacute;routantes.</p><p id="iqq0r8_1612">Il est important de noter que KISS ne signifie pas n&eacute;cessairement choisir la solution la plus simple &agrave; court terme, mais plut&ocirc;t la solution qui reste simple sur toute la dur&eacute;e de vie du code, y compris sa maintenance et son &eacute;volution futures.</p></section></section><section class="chapter"><h3 id="loi-de-demeter-lod" data-toc="loi-de-demeter-lod">Loi de Demeter (LoD)</h3><section class="chapter"><h4 id="principe-de-connaissance-minimale" data-toc="principe-de-connaissance-minimale">Principe de connaissance minimale</h4><p id="iqq0r8_1613"><a href="https://en.wikipedia.org/wiki/Law_of_Demeter" id="iqq0r8_1614" data-external="true" rel="noopener noreferrer">https://en.wikipedia.org/wiki/Law_of_Demeter</a></p><p id="iqq0r8_1615"><a href="https://fr.wikipedia.org/wiki/Loi_de_Déméter" id="iqq0r8_1616" data-external="true" rel="noopener noreferrer">https://fr.wikipedia.org/wiki/Loi_de_D&eacute;m&eacute;ter</a></p><p id="iqq0r8_1617">La Loi de Demeter est un principe de conception en programmation orient&eacute;e objet qui encourage &agrave; r&eacute;duire les d&eacute;pendances entre les objets. Aussi connu sous le nom de principe de <span class="emphasis" id="iqq0r8_1618">moindre connaissance</span>, il stipule qu'un objet ne devrait pas conna&icirc;tre les d&eacute;tails internes des autres objets.</p><p id="iqq0r8_1619">Formellement, la Loi de Demeter stipule que la m&eacute;thode <code class="code" id="iqq0r8_1620">M</code> d'un objet <code class="code" id="iqq0r8_1621">O</code> ne devrait invoquer que les m&eacute;thodes des objets suivants :</p><ul class="list _bullet" id="iqq0r8_1622"><li class="list__item" id="iqq0r8_1623"><p><code class="code" id="iqq0r8_1624">O</code> lui-m&ecirc;me</p></li><li class="list__item" id="iqq0r8_1625"><p>un objet pass&eacute; en param&egrave;tre &agrave; <code class="code" id="iqq0r8_1626">M</code></p></li><li class="list__item" id="iqq0r8_1627"><p>un objet cr&eacute;&eacute; par <code class="code" id="iqq0r8_1628">M</code></p></li><li class="list__item" id="iqq0r8_1629"><p>un objet composant de <code class="code" id="iqq0r8_1630">O</code></p></li></ul><p id="iqq0r8_1631">En d'autres termes, si vous avez un objet <code class="code" id="iqq0r8_1632">A</code> qui contient un objet <code class="code" id="iqq0r8_1633">B</code>, qui &agrave; son tour contient un objet <code class="code" id="iqq0r8_1634">C</code>, la Loi de Demeter sugg&egrave;re qu' <code class="code" id="iqq0r8_1635">A</code> ne devrait pas acc&eacute;der directement &agrave; <code class="code" id="iqq0r8_1636">C</code>. Si vous avez une m&eacute;thode dans <code class="code" id="iqq0r8_1637">A</code> qui a besoin d'interagir avec <code class="code" id="iqq0r8_1638">C</code>, vous devriez avoir une m&eacute;thode dans <code class="code" id="iqq0r8_1639">B</code> qui sert d'interm&eacute;diaire.</p><p id="iqq0r8_1640">L'id&eacute;e derri&egrave;re la loi est de minimiser le couplage entre les objets, en &eacute;vitant qu'un objet ne connaisse trop les d&eacute;tails internes des autres objets. Cela rend le syst&egrave;me dans son ensemble plus modulaire et robuste, car les objets peuvent &ecirc;tre modifi&eacute;s sans affecter grandement les autres objets.</p><p id="iqq0r8_1641">Il est important de noter que la Loi de Demeter est un principe directeur plut&ocirc;t qu'un ensemble de r&egrave;gles strictes &agrave; suivre. Il y aura des situations o&ugrave; il est appropri&eacute; de rompre cette loi dans l'int&eacute;r&ecirc;t d'autres aspects de la conception.</p></section></section><section class="chapter"><h3 id="tell-don-t-ask" data-toc="tell-don-t-ask">Tell Don't ask</h3><p id="iqq0r8_1642"><a href="https://martinfowler.com/bliki/TellDontAsk.html" id="iqq0r8_1643" data-external="true" rel="noopener noreferrer">https://martinfowler.com/bliki/TellDontAsk.html</a></p><p id="iqq0r8_1644"><span class="emphasis" id="iqq0r8_1645"><span class="control" id="iqq0r8_1646">Tell-Don't-Ask</span> is a principle that helps people remember that object-orientation is about bundling data with the functions that operate on that data. It reminds us that rather than asking an object for data and acting on that data, we should instead tell an object what to do.</span></p><p id="iqq0r8_1647"><span class="emphasis" id="iqq0r8_1648"><span class="control" id="iqq0r8_1649">Tell-Don't-Ask</span> est un principe qui aide les gens &agrave; se rappeler que la programmation orient&eacute;e objet consiste &agrave; regrouper des donn&eacute;es avec les fonctions qui op&egrave;rent sur ces donn&eacute;es. Il nous rappelle qu'au lieu de demander &agrave; un objet des donn&eacute;es et d'agir sur ces donn&eacute;es, nous devrions plut&ocirc;t dire &agrave; un objet ce qu'il doit faire.</span></p><p id="iqq0r8_1650">Le principe &quot; <span class="control" id="iqq0r8_1651">Tell, Don't Ask</span> &quot; (Dis-le, ne le demande pas) est un principe de conception en programmation orient&eacute;e objet qui encourage &agrave; dire &agrave; un objet ce qu'il doit faire, plut&ocirc;t que de demander &agrave; l'objet ses donn&eacute;es et de manipuler ces derni&egrave;res.</p><p id="iqq0r8_1652">Essentiellement, cela signifie que vous devriez essayer d'&eacute;viter de demander &agrave; un objet son &eacute;tat, de prendre cet &eacute;tat et de faire quelque chose avec lui. &Agrave; la place, l'objet devrait &ecirc;tre responsable de faire quelque chose avec son propre &eacute;tat.</p><p id="iqq0r8_1653">Voici un exemple pour illustrer ce principe :</p><p id="iqq0r8_1654">Consid&eacute;rons deux classes, <code class="code" id="iqq0r8_1655">Car</code> et <code class="code" id="iqq0r8_1656">Driver</code>. Une approche qui <span class="control" id="iqq0r8_1657">ne</span> suit <span class="control" id="iqq0r8_1658">pas</span> le principe &quot;Tell, Don't Ask&quot; pourrait ressembler &agrave; ceci :</p><div class="code-block" data-lang="java">
public class Driver {
    public void drive() {
        Car car = new Car();
        if (car.getFuel() &gt; 0) {
            car.moveForward();
        }
    }
}
</div><p id="iqq0r8_1660">Le probl&egrave;me ici est que la classe <code class="code" id="iqq0r8_1661">Driver</code> doit demander &agrave; la voiture combien de carburant elle a, puis d&eacute;cider quoi faire en fonction de cette information.</p><p id="iqq0r8_1662">Une approche qui suit le principe &quot;Tell, Don't Ask&quot; pourrait ressembler &agrave; ceci :</p><div class="code-block" data-lang="java">
public class Driver {
    public void drive() {
        Car car = new Car();
        car.moveForward();
    }
}

public class Car {
    public void moveForward() {
        if (this.fuel &gt; 0) {
            // code pour avancer
        }
    }
}
</div><p id="iqq0r8_1664">L'avantage de cette approche est qu'elle d&eacute;centralise la logique et la responsabilit&eacute;, rendant le code plus modulaire et facile &agrave; maintenir et &agrave; comprendre.</p></section><section class="chapter"><h3 id="orthogonalit" data-toc="orthogonalit">Orthogonalit&eacute;</h3><p id="iqq0r8_1665">Le principe d'orthogonalit&eacute; est un concept de conception logicielle qui stipule que les composants d'un syst&egrave;me sont orthogonaux s'ils peuvent &ecirc;tre modifi&eacute;s ind&eacute;pendamment les uns des autres. Autrement dit, changer quelque chose dans une partie du syst&egrave;me n'affecte pas d'autres parties du syst&egrave;me.</p><p id="iqq0r8_1666">L'id&eacute;e vient de l'orthogonalit&eacute; en math&eacute;matiques, o&ugrave; deux vecteurs sont orthogonaux s'ils sont perpendiculaires l'un &agrave; l'autre, signifiant qu'ils n'ont pas d'impact l'un sur l'autre.</p><p id="iqq0r8_1667">Quand ce principe est appliqu&eacute; &agrave; la conception logicielle, il a pour but de minimiser les d&eacute;pendances entre les diff&eacute;rents modules ou composants. Les avantages de ce principe sont :</p><ul class="list _bullet" id="iqq0r8_1668"><li class="list__item" id="iqq0r8_1669"><p><span class="control" id="iqq0r8_1670">Isolation des erreurs</span>: une erreur dans un composant ne se propage pas aux autres.</p></li><li class="list__item" id="iqq0r8_1671"><p><span class="control" id="iqq0r8_1672">Facilit&eacute; de compr&eacute;hension</span>: chaque composant peut &ecirc;tre compris ind&eacute;pendamment des autres.</p></li><li class="list__item" id="iqq0r8_1673"><p><span class="control" id="iqq0r8_1674">Facilit&eacute; de modification</span>: une modification d'un composant n'affecte pas les autres, rendant le d&eacute;veloppement et la maintenance du syst&egrave;me plus faciles.</p></li></ul><p id="iqq0r8_1675">Par exemple, si vous d&eacute;veloppez une application avec une interface utilisateur, une base de donn&eacute;es, et une logique m&eacute;tier, ces trois &eacute;l&eacute;ments devraient &ecirc;tre con&ccedil;us de mani&egrave;re &agrave; ce qu'ils puissent &ecirc;tre d&eacute;velopp&eacute;s et modifi&eacute;s ind&eacute;pendamment les uns des autres. Ils communiqueraient par le biais d'interfaces clairement d&eacute;finies, sans avoir besoin de conna&icirc;tre les d&eacute;tails de mise en &oelig;uvre des autres.</p></section><section class="chapter"><h3 id="viter-l-optimisation-pr-matur-e" data-toc="viter-l-optimisation-pr-matur-e">&Eacute;viter l'optimisation pr&eacute;matur&eacute;e</h3><p id="iqq0r8_1676">L'optimisation pr&eacute;matur&eacute;e est la pratique de l'optimisation micro performante d'un code avant de comprendre clairement quels sont les v&eacute;ritables goulets d'&eacute;tranglement de performance. <span class="emphasis" id="iqq0r8_1677">&quot;&Eacute;viter l'optimisation pr&eacute;matur&eacute;e&quot;</span> est un principe commun&eacute;ment cit&eacute; en programmation, attribu&eacute; &agrave; Donald Knuth, un &eacute;minent informaticien. La citation compl&egrave;te de Knuth est :</p><p id="iqq0r8_1678"><span class="emphasis" id="iqq0r8_1679">&quot;Nous devrions oublier les petites &eacute;conomies, disons environ 97% du temps : l'optimisation pr&eacute;matur&eacute;e est la racine de tous les maux. Pourtant, nous ne devrions pas manquer nos chances dans ce 3% critique.&quot;</span></p><p id="iqq0r8_1680">Ce principe sugg&egrave;re que la majorit&eacute; de l'effort en optimisation devrait &ecirc;tre consacr&eacute;e aux zones d'un programme o&ugrave; les gains de performance auront un impact significatif. Ces zones ne peuvent &ecirc;tre efficacement identifi&eacute;es qu'apr&egrave;s que les probl&eacute;matiques de performances ont &eacute;t&eacute; clairement d&eacute;finies, souvent via le <span class="emphasis" id="iqq0r8_1681">monitoring</span> ou le <span class="emphasis" id="iqq0r8_1682">profilage</span> du code en question.</p><p id="iqq0r8_1683">Cela aide &agrave; &eacute;viter de d&eacute;penser du temps sur des optimisations minuscules qui n'affectent que tr&egrave;s peu les performances globales, tout en rendant potentiellement le code plus complexe et difficile &agrave; maintenir. Cela ne signifie pas que les performances ne sont pas importantes, mais qu'elles doivent &ecirc;tre abord&eacute;es de mani&egrave;re syst&eacute;matique et inform&eacute;e.</p></section><section class="chapter"><h3 id="r-gle-des-5-lignes" data-toc="r-gle-des-5-lignes">R&egrave;gle des 5 lignes</h3><p id="iqq0r8_1684">La &quot;r&egrave;gle des 5 lignes&quot; en d&eacute;veloppement logiciel est une directive heuristique sugg&eacute;rant que les fonctions ou m&eacute;thodes doivent id&eacute;alement &ecirc;tre courtes, g&eacute;n&eacute;ralement dans les cinq lignes de code. L'id&eacute;e derri&egrave;re cette r&egrave;gle est de promouvoir la lisibilit&eacute;, la maintenabilit&eacute; et la simplicit&eacute; du code.</p><p id="iqq0r8_1685">La logique derri&egrave;re la r&egrave;gle des 5 lignes inclut :</p><ol class="list _decimal" id="iqq0r8_1686" type="1"><li class="list__item" id="iqq0r8_1687"><p id="iqq0r8_1688"><span class="control" id="iqq0r8_1689">Lisibilit&eacute;</span>: Des fonctions plus courtes sont plus faciles &agrave; comprendre d'un coup d'&oelig;il, ce qui rend plus simple pour les d&eacute;veloppeurs de comprendre ce que fait la fonction et comment elle atteint son but.</p></li><li class="list__item" id="iqq0r8_1690"><p id="iqq0r8_1691"><span class="control" id="iqq0r8_1692">Maintenabilit&eacute;</span>: Les petites fonctions sont g&eacute;n&eacute;ralement plus faciles &agrave; maintenir et &agrave; modifier. Lorsque les fonctions sont concises, il est plus facile d'isoler et de corriger les bugs, d'ajouter de nouvelles fonctionnalit&eacute;s ou de refactoriser le code sans affecter involontairement d'autres parties du syst&egrave;me.</p></li><li class="list__item" id="iqq0r8_1693"><p id="iqq0r8_1694"><span class="control" id="iqq0r8_1695">Testabilit&eacute;</span>: Les fonctions courtes sont souvent plus faciles &agrave; tester, car elles ont tendance &agrave; avoir moins de chemins d'ex&eacute;cution et de d&eacute;pendances. Cela rend plus simple d'&eacute;crire des tests unitaires qui couvrent tous les sc&eacute;narios possibles.</p></li><li class="list__item" id="iqq0r8_1696"><p id="iqq0r8_1697"><span class="control" id="iqq0r8_1698">R&eacute;duction de la complexit&eacute;</span>: Garder les fonctions courtes peut aider &agrave; r&eacute;duire la complexit&eacute; globale de la base de code. Les fonctions complexes comportant de nombreuses lignes de code sont plus difficiles &agrave; comprendre et sont souvent le signe que la fonction fait trop de choses et devrait &ecirc;tre d&eacute;compos&eacute;e en pi&egrave;ces plus petites et plus g&eacute;rables.</p></li><li class="list__item" id="iqq0r8_1699"><p id="iqq0r8_1700"><span class="control" id="iqq0r8_1701">Am&eacute;lioration de la r&eacute;utilisabilit&eacute;</span>: Les fonctions courtes sont plus susceptibles d'&ecirc;tre r&eacute;utilis&eacute;es dans diff&eacute;rentes parties de la base de code car elles ont tendance &agrave; &ecirc;tre plus cibl&eacute;es et ont une seule responsabilit&eacute;. Cela peut conduire &agrave; un code plus modulaire et plus facile &agrave; maintenir en g&eacute;n&eacute;ral.</p></li></ol><p id="iqq0r8_1702">Il est important de noter que la r&egrave;gle des 5 lignes est une directive plut&ocirc;t qu'une r&egrave;gle stricte. Bien que viser des fonctions courtes soit g&eacute;n&eacute;ralement b&eacute;n&eacute;fique, il peut y avoir des cas o&ugrave; des fonctions plus longues sont n&eacute;cessaires ou appropri&eacute;es. La cl&eacute; est de prioriser la lisibilit&eacute;, la maintenabilit&eacute; et la simplicit&eacute; dans la conception du code et d'utiliser son discernement lors de la d&eacute;termination de la longueur appropri&eacute;e pour une fonction en fonction du contexte sp&eacute;cifique et des exigences du projet logiciel.</p></section><section class="chapter"><h3 id="les-commentaires-de-code-doivent-expliquer-pourquoi-pas-quoi" data-toc="les-commentaires-de-code-doivent-expliquer-pourquoi-pas-quoi">Les commentaires de code doivent expliquer pourquoi, pas quoi</h3><p id="iqq0r8_1703">Cette r&egrave;gle sugg&egrave;re que les commentaires dans le code devraient <span class="control" id="iqq0r8_1704">se concentrer sur l'explication du but, de l'intention, ou de la justification derri&egrave;re le code</span> plut&ocirc;t que de d&eacute;crire ce que fait le code.</p><p id="iqq0r8_1705">Un code bien &eacute;crit devrait &ecirc;tre auto-explicatif, et les commentaires devraient fournir un contexte ou un &eacute;clairage suppl&eacute;mentaire.</p></section><section class="chapter"><h3 id="refactorisation-de-code" data-toc="refactorisation-de-code">Refactorisation de code</h3><p id="iqq0r8_1706">La <span class="control" id="iqq0r8_1707">refactorisation</span> (<span class="emphasis" id="iqq0r8_1708">refactoring</span>) de code est le processus de restructuration du code existant sans en changer le comportement externe afin d'am&eacute;liorer sa lisibilit&eacute;, sa maintenabilit&eacute; et/ou ses performances. Voici quelques r&egrave;gles et directives communes pour la refactorisation de code :</p><ol class="list _decimal" id="iqq0r8_1709" type="1"><li class="list__item" id="iqq0r8_1710"><p id="iqq0r8_1711"><span class="control" id="iqq0r8_1712">R&egrave;gle de trois</span>: cette r&egrave;gle sugg&egrave;re que si vous vous trouvez en train d'&eacute;crire un code similaire pour la troisi&egrave;me fois, il est temps de le refactoriser en une fonction, une m&eacute;thode ou une classe r&eacute;utilisable. Elle aide &agrave; pr&eacute;venir la duplication de code et favorise la r&eacute;utilisabilit&eacute;.</p></li><li class="list__item" id="iqq0r8_1713"><p id="iqq0r8_1714"><span class="control" id="iqq0r8_1715">Refactoriser t&ocirc;t, refactoriser souvent</span>: ce principe pr&eacute;conise de traiter les &quot;odeurs de code&quot; et d'am&eacute;liorer la qualit&eacute; du code en continu tout au long du processus de d&eacute;veloppement, plut&ocirc;t que de laisser la dette technique s'accumuler. Refactoriser r&eacute;guli&egrave;rement de petits morceaux de code peut aider &agrave; garder la base de code propre et maintenable.</p></li><li class="list__item" id="iqq0r8_1716"><p id="iqq0r8_1717"><span class="control" id="iqq0r8_1718">Extraire jusqu'&agrave; &eacute;puisement</span>: lors de la refactorisation, cette r&egrave;gle conseille aux d&eacute;veloppeurs de continuer &agrave; extraire de plus petites fonctions ou m&eacute;thodes &agrave; partir de plus grandes jusqu'&agrave; ce qu'elles ne puissent plus raisonnablement &ecirc;tre d&eacute;compos&eacute;es davantage. Elle favorise la cr&eacute;ation de petites unit&eacute;s de code cibl&eacute;es et r&eacute;utilisables.</p></li><li class="list__item" id="iqq0r8_1719"><p id="iqq0r8_1720"><span class="control" id="iqq0r8_1721">Principes SOLID</span>: ces principes (Single Responsibility, Open/Closed, Liskov Substitution, Interface Segregation et Dependency Inversion) fournissent des directives pour &eacute;crire un code orient&eacute; objet propre, maintenable et extensible. Le respect de ces principes n&eacute;cessite souvent de refactoriser le code existant pour s'y conformer.</p></li><li class="list__item" id="iqq0r8_1722"><p id="iqq0r8_1723"><span class="control" id="iqq0r8_1724">Refactoriser agressivement apr&egrave;s avoir ajout&eacute; des fonctionnalit&eacute;s</span>: chaque fois qu'une nouvelle fonctionnalit&eacute; est ajout&eacute;e &agrave; la base de code, il est recommand&eacute; de passer en revue le code existant et de le refactoriser si n&eacute;cessaire pour maintenir la qualit&eacute; et la coh&eacute;rence du code. Cela aide &agrave; pr&eacute;venir l'accumulation de la dette technique et &agrave; s'assurer que la base de code reste propre et maintenable.</p></li><li class="list__item" id="iqq0r8_1725"><p id="iqq0r8_1726"><span class="control" id="iqq0r8_1727">Utiliser des outils de refactorisation automatis&eacute;s</span>: l'utilisation d'outils de refactorisation automatis&eacute;s fournis par des environnements de d&eacute;veloppement int&eacute;gr&eacute;s (IDE) ou des plugins tiers peut rendre le processus de refactorisation plus efficace et moins sujet aux erreurs. Ces outils peuvent aider &agrave; renommer les variables, &agrave; extraire des m&eacute;thodes et &agrave; effectuer d'autres t&acirc;ches de refactorisation courantes avec un minimum d'effort manuel.</p></li><li class="list__item" id="iqq0r8_1728"><p id="iqq0r8_1729"><span class="control" id="iqq0r8_1730">Pr&eacute;server le comportement avec les tests</span>: lors de la refactorisation du code, il est crucial de s'assurer que le comportement du code reste inchang&eacute;. L'&eacute;criture et la maintenance de tests unitaires exhaustifs peuvent aider &agrave; valider que le code refactoris&eacute; se comporte comme pr&eacute;vu et &agrave; d&eacute;tecter d'&eacute;ventuels effets secondaires involontaires.</p></li></ol></section><section class="chapter"><h3 id="code-smells" data-toc="code-smells">Code smells</h3><p id="iqq0r8_1731">En d&eacute;veloppement logiciel, les <span class="control" id="iqq0r8_1732">&quot;odeurs de code&quot;</span> d&eacute;signent certains mod&egrave;les ou caract&eacute;ristiques du code qui peuvent signaler des probl&egrave;mes plus profonds ou des zones potentiellement am&eacute;liorables. Ce ne sont pas des bugs en soi, mais plut&ocirc;t des indicateurs de probl&egrave;mes de conception ou de violations des bonnes pratiques de codage. Les odeurs de code peuvent rendre le code plus difficile &agrave; comprendre, &agrave; maintenir et &agrave; &eacute;tendre. Identifier et traiter les odeurs de code par la refactorisation peut aider &agrave; am&eacute;liorer la qualit&eacute; et la maintenabilit&eacute; du code. Certaines odeurs de code courantes incluent :</p><ol class="list _decimal" id="iqq0r8_1733" type="1"><li class="list__item" id="iqq0r8_1734"><p id="iqq0r8_1735"><span class="control" id="iqq0r8_1736">Longue M&eacute;thode</span>: Les m&eacute;thodes ou fonctions qui sont excessivement longues et accomplissent plusieurs t&acirc;ches. Les longues m&eacute;thodes sont plus difficiles &agrave; comprendre, &agrave; tester, et &agrave; maintenir.</p></li><li class="list__item" id="iqq0r8_1737"><p id="iqq0r8_1738"><span class="control" id="iqq0r8_1739">Grande Classe</span>: Les classes qui sont trop complexes, avec trop d'attributs et de m&eacute;thodes. Les grandes classes violent le principe de la responsabilit&eacute; unique et peuvent &ecirc;tre difficiles &agrave; g&eacute;rer.</p></li><li class="list__item" id="iqq0r8_1740"><p id="iqq0r8_1741"><span class="control" id="iqq0r8_1742">Code Dupliqu&eacute;</span>: Des fragments de code identiques ou tr&egrave;s similaires apparaissant &agrave; plusieurs endroits. Le code dupliqu&eacute; viole le principe Ne vous r&eacute;p&eacute;tez pas (DRY) et rend la maintenance plus difficile.</p></li><li class="list__item" id="iqq0r8_1743"><p id="iqq0r8_1744"><span class="control" id="iqq0r8_1745">Envie de fonctionnalit&eacute;</span>: Lorsqu'une m&eacute;thode dans une classe acc&egrave;de aux donn&eacute;es ou au comportement d'une autre classe plus qu'&agrave; sa propre donn&eacute;e ou son comportement. Cela sugg&egrave;re que la m&eacute;thode pourrait appartenir &agrave; l'autre classe et indique un &eacute;ventuel probl&egrave;me de conception.</p></li><li class="list__item" id="iqq0r8_1746"><p id="iqq0r8_1747"><span class="control" id="iqq0r8_1748">Obsession Primitive</span>: Utilisation excessive de types de donn&eacute;es primitifs au lieu de cr&eacute;er des classes ou des &eacute;num&eacute;rations personnalis&eacute;es. L'obsession primitive peut conduire &agrave; la duplication de code, &agrave; une lisibilit&eacute; r&eacute;duite, et &agrave; une maintenabilit&eacute; diminu&eacute;e.</p></li><li class="list__item" id="iqq0r8_1749"><p id="iqq0r8_1750"><span class="control" id="iqq0r8_1751">Objet Dieu</span>: Une classe qui sait ou fait trop de choses, devenant souvent un point central de d&eacute;pendances dans la base de code. Les objets dieux sont difficiles &agrave; comprendre, &agrave; tester, et &agrave; maintenir et peuvent conduire &agrave; un code &eacute;troitement coupl&eacute;.</p></li><li class="list__item" id="iqq0r8_1752"><p id="iqq0r8_1753"><span class="control" id="iqq0r8_1754">Commentaires</span>: Des commentaires excessifs ou trompeurs dans le code, qui peuvent indiquer que le code n'est pas auto-explicatif. Bien que les commentaires puissent &ecirc;tre utiles, ils ne doivent pas &ecirc;tre utilis&eacute;s comme substitut &agrave; l'&eacute;criture de code propre et expressif.</p></li><li class="list__item" id="iqq0r8_1755"><p id="iqq0r8_1756"><span class="control" id="iqq0r8_1757">Regroupements de donn&eacute;es</span>: Lorsque des groupes de champs de donn&eacute;es apparaissent ensemble &agrave; plusieurs endroits dans la base de code, sugg&eacute;rant qu'ils pourraient &ecirc;tre encapsul&eacute;s dans une classe s&eacute;par&eacute;e.</p></li><li class="list__item" id="iqq0r8_1758"><p id="iqq0r8_1759"><span class="control" id="iqq0r8_1760">D&eacute;clarations Switch</span>: Utilisation excessive de d&eacute;clarations <code class="code" id="iqq0r8_1761">switch</code> ou <code class="code" id="iqq0r8_1762">case</code>, surtout lorsqu'elles apparaissent &agrave; plusieurs endroits dans la base de code. Les d&eacute;clarations <code class="code" id="iqq0r8_1763">switch</code> peuvent rendre le code plus difficile &agrave; &eacute;tendre et &agrave; maintenir, violant ainsi le principe ouvert/ferm&eacute;.</p></li><li class="list__item" id="iqq0r8_1764"><p id="iqq0r8_1765"><span class="control" id="iqq0r8_1766">Intimit&eacute; Inappropri&eacute;e</span>: Classes qui d&eacute;pendent excessivement les unes des autres en d&eacute;tails internes ou qui ont trop de d&eacute;pendances. L'intimit&eacute; inappropri&eacute;e peut conduire &agrave; un code &eacute;troitement coupl&eacute; qui est difficile &agrave; refactoriser ou &agrave; &eacute;tendre.</p></li></ol><p id="iqq0r8_1767">L'identification et le traitement des odeurs de code est une partie essentielle du processus de refactorisation, aidant &agrave; am&eacute;liorer la qualit&eacute; globale, la lisibilit&eacute;, et la maintenabilit&eacute; de la base de code.</p></section></section><div class="last-modified">Last modified: 04 avril 2024</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom"><a href="patrons-de-conception.html" class="navigation-links__prev">Patrons de conception</a><a href="diagramme-de-classes-figures-geometriques.html" class="navigation-links__next">Diagramme de classes : Figures g&eacute;om&eacute;triques</a></div></article><div id="disqus_thread"></div></div></section></main></div><script src="https://resources.jetbrains.com/writerside/apidoc/6.6.6-b224/app.js"></script></body></html>